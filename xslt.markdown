# XSLT

Stylesheet --- это набор правил-шаблонов, работающих в контексте определенной ноды.
В процессе xslt-преобразования мы обходим в определенном порядке исходное xml-дерево
(т.е. перемещаем текущий контекст от одной ноды к другой) и к каждой контекстной ноде
применяем подходящий шаблон.

## Шаблоны

Каждый шаблон состоит из двух частей:

*   контекста, в котором он работает и
*   действия в этом контексте

Простой пример:

    <xsl:template match="/">
        <html>
            <body>
                <h1>Hello, World</h1>
            </body>
        </html>
    </xsl:template>

### Контекст

Содержимое атрибута `match` --- это xpath, определяющий контекст.
Если в процессе обхода дерева мы попадем в ноду, соответствующую ему,
то будет исполнен этот шаблон.

Важный момент --- если к данной ноде будет несколько подходящих шаблонов,
то будет исполнен только один --- самый подходящий.

### Аналогия с CSS

Правила css устроены похожим образом. У них есть часть, отвечающая за контекст ---
к каким нодам будет применено это правило, и действие --- собственно стили, которые
будут применены к этим нодам.

Отличия:

*   Если несколько css-правил подходят для некоторой ноды, то они будут
    применены все. В xslt это не так --- применяется всегда ровно одно правило.

*   В css отсутствует обход дерева. Т.е. если есть нода и правило, подходящее к ней,
    то оно будет применено. В xslt может быть так, что есть и нода, и шаблон, но при обходе
    дерева контекст не попадет в эту ноду и шаблон не применится.

### Действие

Все, что находится между тегами `<xsl:template>` и `</xsl:template>` описывает результат применения
шаблона к ноде. Более сложный пример:

    <xsl:template match="page">
        <html>
            <head>
                <title><xsl:value-of select="@title"/></title>
            </head>
            <body>
                <xsl:if test="@name = 'index'">
                    <xsl:attribute name="class">index</xsl:attribute>
                </xsl:if>
                <xsl:apply-templates/>
            </body>
        </html>
    </xsl:template>

Что вообще бывает внутри шаблона:

*   Literate result elements --- т.е. это просто html-разметка,
    которая будет скопирована в результирующее дерево.
    Все, что не в неймспейсе xsl просто копируется.

*   XSL-конструкции, которые создают разметку или текст:

    *   xsl:value-of
    *   xsl:text
    *   xsl:element
    *   xsl:attribute
    *   xsl:copy
    *   xsl:copy-of

*   Управляющие xsl-конструкции:

    *   xsl:if
    *   xsl:choose
    *   xsl:for-each

*   XSL-конструкции "меняющие контекст":

    *   xsl:apply-templates
    *   xsl:call-template
    *   xsl:apply-imports

    На самом деле, контекст не обязательно меняется. Можно сказать, что это конструкции,
    позволяющие или поменять контекст, или же просто вызвать другой шаблон (или тот же самый).
    Т.е. они позволяют нам продолжить дальнейший обход дерева в нужном нам порядке.

## Literate result elements

Можно вывести любой html-код. Но. Содержимое шаблона должно быть
валидным xml-фрагментом. В частности, шаблон не может вывести только, скажем,
открывающий тег, или неправильно вложенные теги. Т.е. это не любой html-код,
а любой фрагмент html-дерева.

### Вычисляемые атрибуты

    <xsl:template match="page">
        <html>
        <body class="page page_{@name}">
        ...

Синтаксис внутри атрибута: {XPATH} --- будет заменено на строку,
полученную в результате вычисления этого XPATH'а (в текущем контексте,
если xpath не абсолютный).

## XSL-конструкции, которые создают разметку или текст

### xsl:value-of

    <xsl:value-of select="XPATH"/>


