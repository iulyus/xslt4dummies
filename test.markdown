## XPath

XPath --- способ извлечения информации из xml-документа.

*   Выборка/адресация нужных нод. Результат --- nodeset.
*   Вычисление выражений. Результат --- string, number, boolean.

Несмотря на то, что в названии xpath есть буква *x*, синтаксис xpath-выражений не xml'ный.
XPath --- это просто строка символов. С другой стороны, *path* указывает на сходство
с другими сходными технологиями: пути в файловой системе, урлы и т.д.

### Location Paths --- простейшие xpath'ы

Пример xml'я:

    <page name="index" xmlns:lego="https://lego.yandex-team.ru">
        <lego:l-head>
            <lego:b-head-logo>
                <lego:name>Видео</lego:name>
            </lego:b-head-logo>
        </lego:l-head>
    </page>

Самый простой --- `/`. Выбирает document-ноду.

Простой путь: `/page/lego:l-head`. Т.е. мы выбираем все элементы с именем `lego:l-head`,
которые являются непосредственным потомком элемента `page`, который, с свою очередь,
является непосредственным потомком document-ноды.

Более длинный путь --- `/page/lego:l-head/lego:b-head-logo/lego:name`. Т.е. location path ---
это несколько имен элементов, разделенных символом `/`, который обозначает отношение
"непосредственный потомок".

Практически полный аналог --- это файловая система. Например, `/usr/local/www/lego` ---
обозначает путь в файловой системе. Мы начинаем с корня --- `/`. Затем в корне мы ищем папка
с именем `usr`, если она существует, то в ней ищем папку `local`. И т.д.

Основной отличие: в файловой системе на каждом уровне может быть только один файл с заданным именем,
в xml на любом уровне может быть несколько нод --- результатом является множество нод --- nodeset.

Пример:

    <page name="index" xmlns:lego="https://lego.yandex-team.ru">
        <lego:l-head>
            <lego:b-head-logo>
                <lego:name>Видео</lego:name>
            </lego:b-head-logo>
        </lego:l-head>
        <lego:l-head>
            <lego:b-head-logo>
                <lego:name>Видео</lego:name>
            </lego:b-head-logo>
        </lego:l-head>
    </page>

Применяем тот же xpath --- `/page/lego:l-head/lego:b-head-logo/lego:name`.
Получаем множество, состоящее из двух нод `lego:name`.

`/page/lego:b-head-logo` --- является валидным xpath'ом, несмотря на то, что у элемента `page`
нет непосредственного потомка с именем `lego:b-head-logo`. Такой путь просто вернет
пустое множество нод.

Еще один аналог --- css-селекторы. Например: `div span a b`. Этот селектор выбирает
все элементы `b`, которые находятся внутри элементов `a`, которые находятся внутри `span`...
Правда в xpath разделитель `/` означает непосредственный потомок, а в css-селекторах
пробел означает просто потомок.

Поэтому аналогом xpath'а `/page/lego:l-head/lego:b-head-logo/lego:name`
будет селектор `div > span > a > b`.

Разделитель `//` означает отношение просто потомок (не обязательно непосредственный).
Селектор `/page/lego:b-head-logo` возвращает пустой нодесет, но `/page//lego:b-head-logo`
вернет все элементы `lego:b-head-logo`, находящиеся внутри корневых элементов `page`.

Путь `//lego:name` вернет все элементы `lego:name` в документе, независимо
от их расположения в документе.

Вроде как проще и удобнее писать просто `//lego:name` вместо длинного пути
`/page/lego:l-head/lego:b-head-logo/lego:name`. Но удобство дается не даром,
а за счет падения производительности. Чтобы выполнить первый xpath, нужно
проверить каждый элемент в дереве --- а не является ли он элементом с именем `lego:name`?
Второй путь намного более специфичен и количество нод, которые нужно проверить
намного меньше. Как правило мы избегаем использовать `//`.

Разделители `/` и `//` можно смешивать в одном и том же xpath'е:
`/page/lego:l-head//lego:name`.

### Контекст

Команду `cd /usr/local/www/lego` можно разбить на две части: `cd /usr/local; cd www/lego`.
При этом вторая часть (`cd www/lego`) будет выполняться от результата действия первой.

XPath `/page/lego:l-head/lego:b-head-logo/lego:name` можно выполнять в два захода.
Спервы выбрать ноды, соответствующие xpath'у `/page/lego:l-head`, а затем к тому, что получилось,
применить `b-head-logo/name`.

Или же можно сказать, что мы выполняем `lego:b-head-logo/lego:name` *в контексте* результата действия
`/page/lego:l-head`.

В примере с директориями контекст это текущая директория:

    $ cd /usr/local
    $ pwd
    /usr/local
    $ cd www/lego
    $ pwd
    /usr/local/www/lego

При этом, выполняя команду `cd /usr/local` или применяя xpath `/page/lego:l-head`, мы получаем
одинаковый результат независимо от текущего контекста.

### Относительные и абсолютные пути

XPath'ы, начинающиеся с символа `/` называются *абсолютными*, все остальные --- *относительными*.
Абсолютные пути не зависят от контекста, относительные наоборот.

Результат выполнения команды `cd www/lego` или же xpath'а `lego:b-head-logo/lego:name`
зависят от текущего контекста.

### Атрибуты и родители

`@attr` --- выбирает ноду атрибута с именем `attr`.
Например, `/page/@name`.

Чтобы выбрать родительскую ноду используется конструкция `..`.
В абсолютных путях это не имеет смысла, поэтому `..` обычно применятеся
в относительных путях: `/page/some/other/../tag` это тоже самое, что и `/page/some/tag`.

    <page name="index" xmlns:lego="https://lego.yandex-team.ru">
        <lego:l-head>
            <lego:b-head-logo>
                <lego:name>Видео</lego:name>
            </lego:b-head-logo>
            <lego:b-head-tabs>
                ...
            </lego:b-head-tabs>
            ...
        </lego:l-head>
    </page>

Если мы находимся в контексте `lego:b-head-logo`, то
путь `../lego:b-head-tabs` совпадает с `/page/lego:l-head/lego:b-head-tabs`,
а `../../@name` с `/page/@name`.

`/..` --- всегда возвращает пустой нодесет. Потому что у document-ноды нет родителя.
В некоторых ситуациях бывает удобно гарантированно получить пустой нодесет.

### Текстовые ноды

`/page/lego:l-head/lego:b-head-logo/lego:name/text()` --- текстовая нода

значение нод name и name/text() одинаковое, а ноды разные

если нам нужно именно значение, то можно отбросить text() - шоткат

self xpath: . - собственно контекстный узел

оси: предопределенные наборы узлов в контексте, например:

потомки, атрибуты и т.д.

axis::element

оси: child, descendant, ancestor, self, attribute

шоткаты к ним: *, //, .., ., @

wildcards: *, @*, bla:*, node()

отличие * от node()

@blah:* или blah:@* - не работает

рабочий вариант через предикаты и name()/namespace-uri()

остальные оси: descendant-or-self, ancestor-or-self,

preceding-sibling, following-sibling,

preceding, following, namespace

объединение xpath'ов через пайп

объединение не равно последовательному выполнению

### Расширенное понятие контекста

    <items>
        <item>1</item>
        <item>2</item>
        <item>3</item>
    </items>

Возьмем простой xpath: `/items/item` --- он выбирает все три элемента `item`.
Эти элементы образуют *коллекцию* нод и, если мы обрабатываем эти ноды, то
мы их обрабатываем не как независимые ноды, а как ноды из этой коллекции.
Для каждого элемента контекст состоит не просто из этой одной ноды.
Контекст состоит из:

*   Длины коллекции
*   Позиции данного элемента в коллекции
*   Собственно контекстной ноды

Т.е. может быть ситуация, когда контекстная нода одинаковая, но контекст целиком разный.

